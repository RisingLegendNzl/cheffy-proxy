const fetch = require('node-fetch');
// --- REMOVED (Mark 51): Import axios ---
const { createClient } = require('@vercel/kv');

// --- Create KV client ---
const kv = createClient({
    url: process.env.UPSTASH_REDIS_REST_URL,
    token: process.env.UPSTASH_REDIS_REST_TOKEN,
});

// --- CACHE CONFIGURATION ---
const TTL_NUTRI_BARCODE_MS = 1000 * 60 * 60 * 24 * 30; // 30 days (OFF Barcode)
const SWR_NUTRI_BARCODE_MS = 1000 * 60 * 60 * 24 * 10;
const TTL_NUTRI_NAME_MS = 1000 * 60 * 60 * 24 * 7;    // 7 days (OFF Name, USDA Name)
const SWR_NUTRI_NAME_MS = 1000 * 60 * 60 * 24 * 2;
const CACHE_PREFIX_NUTRI = 'nutri';

// --- USDA API CONFIGURATION ---
const USDA_API_KEY = process.env.USDA_API_KEY;
const USDA_SEARCH_URL = 'https://api.nal.usda.gov/fdc/v1/foods/search';
const USDA_DETAILS_URL = 'https://api.nal.usda.gov/fdc/v1/food/'; // Append {fdcId}?api_key=...
// --- MODIFICATION (Mark 55): Reduced USDA Fetch Timeout ---
const USDA_FETCH_TIMEOUT_MS = 8000; // 8 seconds timeout for USDA calls
// --- END MODIFICATION ---

// --- TOKEN BUCKET CONFIGURATION (USDA) ---
const BUCKET_CAPACITY = 10;
const BUCKET_REFILL_RATE = 1; // 1 req/sec base limit
const BUCKET_RETRY_DELAY_MS = 1100;
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

// --- CONSTANT FOR UNIT CORRECTION ---
const KJ_TO_KCAL_FACTOR = 4.184;

// --- NEW (Mark 55): Canonical Nutrition Table ---
// Approximate values per 100g, AU-centric where possible
const CANONICAL_NUTRITION_TABLE_V1 = {
    // Queries should match the 'nutritionQuery' generated by AI Phase 1
    'banana fresh':            { calories: 89,  protein: 1.1, fat: 0.3, carbs: 22.8, fiber: 2.6, sodium: 0.001 }, // Sodium in g
    'wholegrain bread slice':  { calories: 250, protein: 10,  fat: 3.5, carbs: 40,   fiber: 7,   sodium: 0.450 }, // Generic slice ~40g, scaled to 100g
    'canned tuna in water':    { calories: 110, protein: 25,  fat: 1.0, carbs: 0,    fiber: 0,   sodium: 0.350 }, // Drained, springwater
    'canola oil spray':        { calories: 884, protein: 0,   fat: 100, carbs: 0,    fiber: 0,   sodium: 0     }, // Treat as pure canola oil per 100g for calculation
    'rolled oats dry':         { calories: 370, protein: 12,  fat: 7,   carbs: 60,   fiber: 10,  sodium: 0.005 },
    'brown rice raw':          { calories: 360, protein: 7.5, fat: 2.7, carbs: 76,   fiber: 3.4, sodium: 0.005 },
    'white rice raw':          { calories: 360, protein: 7,   fat: 0.7, carbs: 79,   fiber: 1,   sodium: 0.005 }, // Added white rice
    'smooth peanut butter':    { calories: 590, protein: 25,  fat: 50,  carbs: 16,   fiber: 6,   sodium: 0.450 }  // Commercial, salted
};
// --- END NEW ---


// Track ongoing refreshes
const inflightRefreshes = new Set();

// Normalize cache keys
const normalizeKey = (str) => (str || '').toString().toLowerCase().trim().replace(/\s+/g, '_');

// Check if KV is configured
const isKvConfigured = () => {
    return process.env.UPSTASH_REDIS_REST_URL && process.env.UPSTASH_REDIS_REST_TOKEN;
};


// --- MODIFIED (Mark 55): Updated USDA Normalizer ---
/**
 * Normalizes USDA FoodData Central API details response.
 * Requires energy_kcal, protein_g, fat_g, carbs_g per 100g.
 */
function normalizeUsdaResponse(usdaDetailsResponse, query, log) {
    const defaultResult = { complete: false, reason: 'unknown', data: null }; // Structure for failure return

    if (!usdaDetailsResponse || !Array.isArray(usdaDetailsResponse.foodNutrients)) {
        log(`USDA: No valid foodNutrients array for query: ${query} (FDC ID: ${usdaDetailsResponse?.fdcId})`, 'WARN', 'USDA_PARSE');
        defaultResult.reason = 'no_foodNutrients_array';
        return defaultResult;
    }

    const nutrients = usdaDetailsResponse.foodNutrients;
    const foodDescription = usdaDetailsResponse.description || 'Unknown Food';
    const fdcId = usdaDetailsResponse.fdcId || 'N/A';
    log(`USDA: Normalizing response for "${foodDescription}" (FDC ID: ${fdcId})`, 'DEBUG', 'USDA_PARSE', { nutrientCount: nutrients.length });

    // Helper to find and scale nutrient value to per 100g, handling g/mg/mcg/kcal/kJ
    const getNutrientPer100g = (nutrientIds, targetUnit) => {
        let valueFound = null;
        let unitFound = '';

        for (const nutrientId of nutrientIds) {
            const nutrient = nutrients.find(n => n.nutrient?.id === nutrientId && n.amount !== undefined && n.amount !== null);
            if (nutrient) {
                const amount = parseFloat(nutrient.amount);
                const unit = (nutrient.unitName || '').toUpperCase();
                log(`USDA: Checking ID ${nutrientId}, Amount: ${amount}, Unit: ${unit}`, 'DEBUG', 'USDA_PARSE_DETAIL');

                if (!isNaN(amount)) {
                    unitFound = unit; // Store the unit we actually found
                    // Direct unit matches (per 100g)
                    if (unit === targetUnit.toUpperCase()) {
                        valueFound = amount;
                        break; // Found exact match
                    }
                    // Conversions (assuming USDA values are always per 100g basis)
                    else if (targetUnit.toUpperCase() === 'G' && unit === 'MG') {
                        valueFound = amount / 1000;
                        unitFound = 'MG -> G';
                        break;
                    } else if (targetUnit.toUpperCase() === 'G' && unit === 'MCG') {
                        valueFound = amount / 1000000;
                        unitFound = 'MCG -> G';
                        break;
                    } else if (targetUnit.toUpperCase() === 'KCAL' && unit === 'KJ') {
                        // Only use KJ if KCAL wasn't already found directly via its ID
                        if (valueFound === null) {
                            valueFound = amount / KJ_TO_KCAL_FACTOR;
                            unitFound = 'KJ -> KCAL';
                            // Continue searching IDs in case a direct KCAL value exists later
                        }
                    } else {
                        log(`USDA: Found ID ${nutrientId} but unit "${unit}" doesn't match target "${targetUnit}" and no conversion defined.`, 'DEBUG', 'USDA_PARSE_DETAIL');
                    }
                } else {
                    log(`USDA: Found nutrient ID ${nutrientId}, but amount "${nutrient.amount}" is not a valid number.`, 'WARN', 'USDA_PARSE_DETAIL');
                }
            } else {
                 log(`USDA: Nutrient ID ${nutrientId} not found or amount missing.`, 'DEBUG', 'USDA_PARSE_DETAIL');
            }
        } // End loop through nutrient IDs

        if (valueFound !== null) {
            log(`USDA: Final value for target ${targetUnit} (IDs: ${nutrientIds.join(',')}) = ${valueFound.toFixed(3)} (${unitFound})`, 'INFO', 'USDA_PARSE_RESULT');
            return valueFound;
        } else {
            log(`USDA: Could not find valid value for target ${targetUnit} (IDs: ${nutrientIds.join(',')})`, 'WARN', 'USDA_PARSE_RESULT');
            return null; // Return null if not found/parsed
        }
    };

    // Preferred USDA Nutrient IDs: (Primary, Secondary/Older)
    const kcalIds = [1008, 208];       // Energy (kcal)
    const proteinIds = [1003, 203];    // Protein
    const fatIds = [1004, 204];        // Total lipid (fat)
    const carbIds = [1005, 205];       // Carbohydrate, by difference or sum
    const satFatIds = [1258, 606];     // Fatty acids, total saturated
    const sugarsIds = [2000, 269];     // Sugars, total including NLEA
    const fiberIds = [1079, 291];      // Fiber, total dietary
    const sodiumIds = [1093, 307];     // Sodium, Na

    // Get core values using the helper, returns null if not found/parsed
    const calories = getNutrientPer100g(kcalIds, 'KCAL');
    const protein = getNutrientPer100g(proteinIds, 'G');
    const fat = getNutrientPer100g(fatIds, 'G');
    const carbs = getNutrientPer100g(carbIds, 'G');

    // --- Strict Check: Essential macros must exist, be non-negative, and calories > 0 ---
    const coreMacrosValid = (
        calories !== null && calories > 0 &&
        protein !== null && protein >= 0 &&
        fat !== null && fat >= 0 &&
        carbs !== null && carbs >= 0
    );

    if (!coreMacrosValid) {
        log(`USDA: Core macros missing or invalid after parsing for "${foodDescription}" (FDC ID: ${fdcId})`, 'WARN', 'USDA_PARSE_FAIL', { calories, protein, fat, carbs });
        defaultResult.reason = 'core_macros_missing_or_invalid';
        return defaultResult;
    }

    log(`USDA: Successfully parsed essential data for "${foodDescription}" (FDC ID: ${fdcId})`, 'SUCCESS', 'USDA_PARSE');

    // Get optional values, defaulting to 0 if not found
    const saturatedFat = getNutrientPer100g(satFatIds, 'G') ?? 0;
    const sugars = getNutrientPer100g(sugarsIds, 'G') ?? 0;
    const fiber = getNutrientPer100g(fiberIds, 'G') ?? 0;
    const sodium = getNutrientPer100g(sodiumIds, 'G') ?? 0; // Target G, helper handles MG

    // Attempt to construct ingredients list
    const ingredientsText = usdaDetailsResponse.inputFoods?.map(f => f.foodDescription).join(', ') || usdaDetailsResponse.ingredients || foodDescription || null;

    // Return structured success object
    return {
        complete: true,
        reason: 'success',
        data: {
            status: 'found',
            source: 'usda',
            servingUnit: '100g', // USDA is per 100g
            calories: calories,
            protein: protein,
            fat: fat,
            saturatedFat: saturatedFat,
            carbs: carbs,
            sugars: sugars,
            fiber: fiber,
            sodium: sodium,
            ingredientsText: ingredientsText
        }
    };
}
// --- END NORMALIZER ---


/**
 * Internal logic for fetching from USDA API (Search then Details) with timeout.
 */
async function _fetchUsdaFromApi(query, log = console.log) {
    if (!USDA_API_KEY) {
        log('Configuration Error: USDA_API_KEY is not set.', 'CRITICAL', 'CONFIG');
        return { error: { message: 'Server configuration error: USDA API key missing.', status: 500 }, source: 'usda_config' };
    }

    let searchTimeoutId, detailsTimeoutId;
    let searchAbortController = new AbortController();
    let detailsAbortController = new AbortController();

    try {
        // --- Step 1: Search ---
        searchTimeoutId = setTimeout(() => searchAbortController.abort(), USDA_FETCH_TIMEOUT_MS);
        const searchStartTime = Date.now();
        const searchUrl = `${USDA_SEARCH_URL}?api_key=${USDA_API_KEY}&query=${encodeURIComponent(query)}&pageSize=10&dataType=Foundation,SR%20Legacy,Survey%20(FNDDS),Branded`;
        log(`Attempting USDA search for: ${query}`, 'DEBUG', 'USDA_REQUEST', { url: searchUrl.split('?')[0] + '?query=...' });

        const searchResponse = await fetch(searchUrl, { signal: searchAbortController.signal });
        clearTimeout(searchTimeoutId); // Clear timeout on success/error
        const searchLatencyMs = Date.now() - searchStartTime;

        if (!searchResponse.ok) {
            if (searchResponse.status === 429) {
                 log(`USDA search returned 429 for "${query}".`, 'WARN', 'USDA_FAILURE', { status: 429, latency_ms: searchLatencyMs });
                 const rateLimitError = new Error(`USDA API rate limit hit (search)`);
                 rateLimitError.statusCode = 429;
                 throw rateLimitError;
            }
            const errorBody = await searchResponse.text();
            log(`USDA search failed for "${query}" status ${searchResponse.status}`, 'WARN', 'USDA_FAILURE', { status: searchResponse.status, latency_ms: searchLatencyMs, body: errorBody });
            return { error: { message: `USDA search failed. Status: ${searchResponse.status}`, status: searchResponse.status, details: errorBody }, source: 'usda_search' };
        }
        const searchResponseData = await searchResponse.json();
        log(`USDA search OK for "${query}". Found ${searchResponseData?.totalHits} matches.`, 'DEBUG', 'USDA_RESPONSE', { latency_ms: searchLatencyMs });

        // --- Step 2: Find Best FDC ID ---
        if (!searchResponseData || !Array.isArray(searchResponseData.foods) || searchResponseData.foods.length === 0) {
            log(`USDA search for "${query}" returned no results.`, 'INFO', 'USDA_RESPONSE');
            return { error: { message: 'No results found in USDA search', status: 404 }, source: 'usda_search_no_results' };
        }

        let bestFdcId = null;
        let foundFoodDescription = '';
        const preferredTypes = ['Foundation', 'SR Legacy', 'Survey (FNDDS)']; // Prefer generic types
        // --- Logic to select best match (prioritize preferred types, then fallback) ---
        for (const type of preferredTypes) {
             const exactMatch = searchResponseData.foods.find(food => food.dataType === type && food.description.toLowerCase() === query.toLowerCase());
             const containsMatch = searchResponseData.foods.find(food => food.dataType === type && food.description.toLowerCase().includes(query.toLowerCase()));
             const foundFood = exactMatch || containsMatch;
            if (foundFood) {
                bestFdcId = foundFood.fdcId;
                foundFoodDescription = foundFood.description;
                log(`USDA selected FDC ID ${bestFdcId} ("${foundFoodDescription}", Type: ${type}) for query "${query}"`, 'INFO', 'USDA_SELECT');
                break;
            }
        }
        if (!bestFdcId && searchResponseData.foods.length > 0) {
            bestFdcId = searchResponseData.foods[0].fdcId;
            foundFoodDescription = searchResponseData.foods[0].description;
            const fallbackType = searchResponseData.foods[0].dataType;
            log(`USDA falling back to first result FDC ID ${bestFdcId} ("${foundFoodDescription}", Type: ${fallbackType}) for query "${query}"`, 'INFO', 'USDA_SELECT');
        }
        if (!bestFdcId) {
             log(`USDA failed to select an FDC ID for query "${query}"`, 'ERROR', 'USDA_SELECT');
             return { error: { message: 'Failed to select FDC ID from search results', status: 500 }, source: 'usda_select_fail' };
        }

        // --- Step 3: Fetch Details ---
        detailsTimeoutId = setTimeout(() => detailsAbortController.abort(), USDA_FETCH_TIMEOUT_MS);
        const detailsStartTime = Date.now();
        const detailsUrl = `${USDA_DETAILS_URL}${bestFdcId}?api_key=${USDA_API_KEY}`;
        log(`Attempting USDA details fetch for FDC ID: ${bestFdcId}`, 'DEBUG', 'USDA_REQUEST', { url: detailsUrl.split('?')[0] + '?api_key=...' });

        const detailsResponse = await fetch(detailsUrl, { signal: detailsAbortController.signal });
        clearTimeout(detailsTimeoutId); // Clear timeout
        const detailsLatencyMs = Date.now() - detailsStartTime;

         if (!detailsResponse.ok) {
              if (detailsResponse.status === 429) {
                 log(`USDA details returned 429 for FDC ID ${bestFdcId}.`, 'WARN', 'USDA_FAILURE', { status: 429, latency_ms: detailsLatencyMs });
                 const rateLimitError = new Error(`USDA API rate limit hit (details)`);
                 rateLimitError.statusCode = 429;
                 throw rateLimitError;
              }
             const errorBody = await detailsResponse.text();
             log(`USDA details fetch failed for FDC ID ${bestFdcId} status ${detailsResponse.status}`, 'WARN', 'USDA_FAILURE', { status: detailsResponse.status, latency_ms: detailsLatencyMs, body: errorBody });
             return { error: { message: `USDA details fetch failed. Status: ${detailsResponse.status}`, status: detailsResponse.status, details: errorBody }, source: 'usda_details' };
         }
        const detailsData = await detailsResponse.json();
        log(`USDA details fetch successful for FDC ID ${bestFdcId}`, 'SUCCESS', 'USDA_RESPONSE', { latency_ms: detailsLatencyMs });
        return detailsData; // Return raw details JSON

    } catch (error) {
        // Clear any potentially pending timeouts
        clearTimeout(searchTimeoutId);
        clearTimeout(detailsTimeoutId);
        const latencyMs = Date.now() - (detailsStartTime || searchStartTime); // Use appropriate start time

        // Handle AbortError specifically as a timeout
         if (error.name === 'AbortError') {
            const stage = detailsStartTime ? 'details' : 'search'; // Determine which stage timed out
             log(`USDA ${stage} fetch timed out after ${USDA_FETCH_TIMEOUT_MS}ms for query "${query}" (FDC ID: ${bestFdcId || 'N/A'}).`, 'ERROR', 'USDA_TIMEOUT');
             return { error: { message: `USDA ${stage} fetch timed out.`, status: 504 }, source: `usda_${stage}_timeout`, timeout_ms: USDA_FETCH_TIMEOUT_MS };
         }
         // Handle specific 429 error
         if (error.statusCode === 429) throw error; // Re-throw for rate limiter handling
         // Handle other network/fetch errors
        log(`USDA network/fetch error during query "${query}": ${error.message}`, 'ERROR', 'USDA_FAILURE', { latency_ms: latencyMs });
        return { error: { message: `USDA network/fetch error: ${error.message}`, status: 504 }, source: 'usda_fetch_error' };
    } finally {
         // Ensure timeouts are cleared even if error handling fails somehow
         clearTimeout(searchTimeoutId);
         clearTimeout(detailsTimeoutId);
    }
}


/**
 * Wrapper for USDA API calls using a STATELESS token bucket (Vercel KV).
 */
async function fetchUsdaSafe(query, log = console.log) {
    const bucketKey = `bucket:usda`;
    const refillRatePerMs = BUCKET_REFILL_RATE / 1000;
    let waitMs = 0;
    const waitStart = Date.now();

    while (true) { // Loop for acquiring token
        const now = Date.now();
        let bucketState = null;

        if (isKvConfigured()) {
            try {
                bucketState = await kv.get(bucketKey);
            } catch (kvError) {
                log(`CRITICAL: KV GET failed for bucket ${bucketKey}. Bypassing rate limit.`, 'CRITICAL', 'KV_ERROR', { error: kvError.message });
                break; // Bypass loop on KV error
            }
        }

        if (!bucketState) { // Initialize bucket
            log(`Initializing KV bucket: ${bucketKey}`, 'DEBUG', 'BUCKET_INIT');
            if (isKvConfigured()) {
                try {
                    await kv.set(bucketKey, { tokens: BUCKET_CAPACITY - 1, lastRefill: now }, { ex: 86400 }); // 1 day TTL
                } catch (kvError) {
                    log(`Warning: KV SET failed for bucket ${bucketKey}.`, 'WARN', 'KV_ERROR', { error: kvError.message });
                }
            }
            break; // Token acquired
        }

        // Refill logic
        const elapsedMs = now - bucketState.lastRefill;
        const tokensToAdd = elapsedMs * refillRatePerMs;
        let currentTokens = Math.min(BUCKET_CAPACITY, bucketState.tokens + tokensToAdd);
        const newLastRefill = now;

        if (currentTokens >= 1) { // Take token
            currentTokens -= 1;
            if (isKvConfigured()) {
                try {
                    await kv.set(bucketKey, { tokens: currentTokens, lastRefill: newLastRefill }, { ex: 86400 });
                } catch (kvError) {
                    log(`Warning: KV SET failed for bucket ${bucketKey}.`, 'WARN', 'KV_ERROR', { error: kvError.message });
                }
            }
            break; // Token acquired
        } else { // Wait
            const tokensNeeded = 1 - currentTokens;
            const waitTime = Math.max(50, Math.ceil(tokensNeeded / refillRatePerMs));
            log(`Rate limiter active (USDA). Waiting ${waitTime}ms...`, 'INFO', 'BUCKET_WAIT');
            await delay(waitTime);
            // Continue loop to re-check after delay
        }
    } // end while(true)

    waitMs = Date.now() - waitStart;
    log(`Acquired token for USDA (waited ${waitMs}ms)`, 'DEBUG', 'BUCKET_TAKE', { bucket_wait_ms: waitMs });

    try {
        const data = await _fetchUsdaFromApi(query, log); // Call internal function with timeout
        return { data, waitMs };
    } catch (error) {
        if (error.statusCode === 429) { // Handle 429 retry
            log(`USDA returned 429. Retrying once after ${BUCKET_RETRY_DELAY_MS}ms...`, 'WARN', 'BUCKET_RETRY', { query });
            await delay(BUCKET_RETRY_DELAY_MS);
             try {
                 const retryData = await _fetchUsdaFromApi(query, log); // Retry internal function
                 return { data: retryData, waitMs };
             } catch (retryError) {
                  log(`Retry after 429 failed (USDA): ${retryError.message}`, 'ERROR', 'BUCKET_RETRY_FAIL', { query });
                  const status = retryError.status || retryError.statusCode || 500;
                  const errorData = { error: { message: `Retry after 429 failed. Status: ${status}`, status: status, details: retryError.message }, source: retryError.source || 'usda_retry' };
                  return { data: errorData, waitMs };
             }
        }
        // Other errors (including timeout errors passed up from _fetchUsdaFromApi)
        log(`Unhandled error during fetchUsdaSafe: ${error.message}`, 'CRITICAL', 'BUCKET_ERROR', { query });
         const errorData = { error: { message: `Unexpected error during safe USDA fetch: ${error.message}`, status: error.status || 500 }, source: error.source || 'usda_safe' };
         return { data: errorData, waitMs };
    }
}


/**
 * Internal logic for fetching nutrition data from Open Food Facts API (and USDA fallback).
 * Mark 55: Refined trigger condition for USDA fallback & added canonical table.
 */
async function _fetchNutritionDataFromApi(barcode, query, log = console.log) {
    let offNutritionResult = null; // Store OFF result temporarily
    let offFetchFailed = false; // Flag for explicit fetch failure
    let offIsIncomplete = false; // Flag if OFF data found but is incomplete
    let reasonIncomplete = 'n/a'; // Reason for fallback

    const identifier = barcode || query;
    const identifierType = barcode ? 'barcode' : 'query';
    if (!identifier) {
        log('Missing barcode or query for nutrition search.', 'WARN', 'INPUT');
        return { status: 'not_found', error: 'Missing barcode or query parameter', source: 'input_error' };
    }

    // --- STAGE 1: Attempt Open Food Facts ---
    const startTime = Date.now();
    try {
        let openFoodFactsURL = '';
        if (barcode) {
            openFoodFactsURL = `https://world.openfoodfacts.org/api/v2/product/${barcode}.json`;
        } else if (query) {
            openFoodFactsURL = `https://world.openfoodfacts.org/cgi/search.pl?search_terms=${encodeURIComponent(query)}&search_simple=1&action=process&json=1&page_size=1`;
        }
        log(`Requesting nutrition (OFF) for ${identifierType}: ${identifier}`, 'DEBUG', 'OFF_REQUEST');

        const offAbortController = new AbortController();
        const offTimeoutId = setTimeout(() => offAbortController.abort(), 15000); // 15s timeout
        const apiResponse = await fetch(openFoodFactsURL, {
            method: 'GET',
            headers: { 'User-Agent': 'CheffyApp/1.0 (dev@cheffy.com)' },
            signal: offAbortController.signal
        });
        clearTimeout(offTimeoutId);
        const latencyMs = Date.now() - startTime;

        if (apiResponse.ok) {
            const data = await apiResponse.json();
            const product = barcode ? data.product : (data.products && data.products[0]);

            if (product && product.nutriments) {
                const nutriments = product.nutriments;
                const parseNutrient = (value) => (value === undefined || value === null || value === '') ? null : (isNaN(parseFloat(value)) ? null : parseFloat(value));

                let calories = parseNutrient(nutriments['energy-kcal_100g']);
                if (calories === null || calories <= 0) {
                    const kj = parseNutrient(nutriments['energy-kj_100g']);
                    if (kj !== null && kj > 0) {
                        calories = kj / KJ_TO_KCAL_FACTOR;
                    } else { calories = null; }
                }
                const protein = parseNutrient(nutriments.proteins_100g);
                const fat = parseNutrient(nutriments.fat_100g);
                const carbs = parseNutrient(nutriments.carbohydrates_100g);

                // --- Stricter Completeness Check (Mark 55) ---
                const isComplete = (
                    calories !== null && calories > 0 &&
                    protein !== null && protein >= 0 &&
                    fat !== null && fat >= 0 &&
                    carbs !== null && carbs >= 0
                );
                // Additional check based on ChatGPT suggestion: if energy > 50, P/F/C should not all be zero
                const plausibilityCheck = !(calories !== null && calories > 50 && protein === 0 && fat === 0 && carbs === 0);

                if (isComplete && plausibilityCheck) {
                    log(`OFF: Successfully fetched complete data for ${identifier}`, 'SUCCESS', 'OFF_RESPONSE', { latency_ms: latencyMs });
                    offNutritionResult = {
                        status: 'found', source: 'openfoodfacts', servingUnit: product.nutrition_data_per || '100g',
                        calories: calories, protein: protein, fat: fat, carbs: carbs,
                        saturatedFat: parseNutrient(nutriments['saturated-fat_100g']) ?? 0,
                        sugars: parseNutrient(nutriments.sugars_100g) ?? 0,
                        fiber: parseNutrient(nutriments.fiber_100g) ?? 0,
                        sodium: parseNutrient(nutriments.sodium_100g) ?? 0,
                        ingredientsText: product.ingredients_text || null
                    };
                    return offNutritionResult; // Found complete data, return now
                } else {
                     offIsIncomplete = true; // Mark as incomplete
                     reasonIncomplete = !isComplete ? 'essential_macros_missing_zero' : 'implausible_zeros';
                     log(`OFF: Data incomplete/invalid for ${identifier}. Reason: ${reasonIncomplete}`, 'INFO', 'OFF_INCOMPLETE', { latency_ms: latencyMs, data: { calories, protein, fat, carbs } });
                }
            } else {
                 offIsIncomplete = true; // Mark as incomplete
                 reasonIncomplete = 'product_or_nutriments_missing';
                 log(`OFF: Product/nutriments structure missing for ${identifier}`, 'INFO', 'OFF_MISSING', { latency_ms: latencyMs, productFound: !!product });
            }
        } else {
             offFetchFailed = true; // Mark as explicit failure
             reasonIncomplete = `http_status_${apiResponse.status}`;
             log(`OFF API returned: ${apiResponse.status} for ${identifier}`, 'WARN', 'OFF_RESPONSE', { status: apiResponse.status, latency_ms: latencyMs });
        }
    } catch (error) {
        clearTimeout(offTimeoutId); // Ensure timeout cleared on error
        const latencyMs = Date.now() - startTime;
        offFetchFailed = true; // Mark as explicit failure
        reasonIncomplete = error.name === 'AbortError' ? 'timeout_15s' : 'network_error';
        if (error.name === 'AbortError') {
             log(`OFF Fetch timed out after 15s for "${identifier}".`, 'ERROR', 'OFF_TIMEOUT');
        } else {
             log(`OFF Fetch Error for "${identifier}": ${error.message}`, 'ERROR', 'OFF_FAILURE', { latency_ms: latencyMs });
        }
    }

    // --- STAGE 2: Attempt USDA Fallback ---
    // Trigger condition: OFF fetch failed OR was incomplete, AND we have a query to use
    const shouldTryUsda = (offFetchFailed || offIsIncomplete) && query;

    if (shouldTryUsda) {
        log(`OFF failed/incomplete for "${identifier}" (Reason: ${reasonIncomplete}). Attempting USDA fallback...`, 'INFO', 'USDA_ATTEMPT');

        const { data: usdaRawData } = await fetchUsdaSafe(query, log); // Use rate-limited wrapper with timeout

        if (usdaRawData && !usdaRawData.error) {
            const normalizedResult = normalizeUsdaResponse(usdaRawData, query, log); // Use updated normalizer
            if (normalizedResult.complete) {
                log(`USDA fallback SUCCESS for query "${query}"`, 'SUCCESS', 'USDA_FOUND');
                return normalizedResult.data; // Success with USDA!
            } else {
                reasonIncomplete = `usda_parse_fail (${normalizedResult.reason})`;
                log(`USDA fallback fetched but FAILED PARSING for: ${query}. Reason: ${normalizedResult.reason}`, 'WARN', 'USDA_PARSE_FAIL', { fdcId: usdaRawData.fdcId });
                // Proceed to Canonical fallback
            }
        } else {
             // Log USDA fetch failure (timeout, 404, 429, etc.)
             reasonIncomplete = `usda_fetch_fail (${usdaRawData?.source || 'unknown'})`;
             log(`USDA fallback fetch FAILED for: ${query}`, 'ERROR', 'USDA_FETCH_FAIL', { error: usdaRawData?.error, source: usdaRawData?.source });
             // Proceed to Canonical fallback
        }
    } else if (!query && (offFetchFailed || offIsIncomplete)) {
        // Log case where OFF failed but no query was available for USDA/Canonical
        log(`OFF failed/incomplete for "${identifier}". No query provided for USDA/Canonical fallback.`, 'WARN', 'NUTRITION_NO_QUERY');
        reasonIncomplete = offFetchFailed ? `off_fetch_fail_no_query` : `off_incomplete_no_query`;
    }

    // --- STAGE 3: Attempt Canonical Fallback ---
    // Trigger condition: We have a query AND previous stages failed (reasonIncomplete is set)
    const normalizedQuery = query ? normalizeKey(query) : null;
    if (normalizedQuery && reasonIncomplete !== 'n/a' && CANONICAL_NUTRITION_TABLE_V1[normalizedQuery]) {
        const canonicalData = CANONICAL_NUTRITION_TABLE_V1[normalizedQuery];
        log(`Using CANONICAL fallback for query "${query}" (Reason: ${reasonIncomplete})`, 'INFO', 'CANONICAL_FALLBACK');

        // --- Trigger background refresh only if USDA timed out or failed (Mark 55) ---
        if (reasonIncomplete.startsWith('usda_')) {
             const cacheKey = `${CACHE_PREFIX_NUTRI}:name:${normalizedQuery}`; // Use the same cache key as regular query
             const ttlMs = TTL_NUTRI_NAME_MS;
             const keyType = 'nutri_name_usda_refresh';
             log(`Triggering background USDA refresh for "${query}" after serving canonical.`, 'INFO', 'SWR_REFRESH_USDA');
             refreshInBackground(cacheKey, null, query, ttlMs, log, keyType); // Trigger refresh
        }

        return {
            status: 'found',
            source: 'canonical_v1',
            servingUnit: '100g',
            calories: canonicalData.calories,
            protein: canonicalData.protein,
            fat: canonicalData.fat,
            carbs: canonicalData.carbs,
            saturatedFat: canonicalData.saturatedFat ?? 0,
            sugars: canonicalData.sugars ?? 0,
            fiber: canonicalData.fiber ?? 0,
            sodium: canonicalData.sodium ?? 0,
            ingredientsText: `Generic ${query} (canonical data)`
        };
    } else if (normalizedQuery && reasonIncomplete !== 'n/a') {
         log(`Query "${query}" not found in canonical table after previous failures (Reason: ${reasonIncomplete}).`, 'WARN', 'CANONICAL_MISS');
    }

    // --- STAGE 4: Definitive Failure ---
    log(`All nutrition sources failed for ${identifierType}: ${identifier} (Final Reason: ${reasonIncomplete})`, 'WARN', 'NUTRITION_FAIL_ALL');
    return { status: 'not_found', reason_incomplete: reasonIncomplete };
}


/**
 * Initiates a background refresh for a nutrition cache key.
 * Mark 55: Can now trigger USDA refresh.
 */
async function refreshInBackground(cacheKey, barcode, query, ttlMs, log, keyType) {
    if (inflightRefreshes.has(cacheKey)) {
        log(`Nutri refresh already in progress for ${cacheKey}, skipping.`, 'DEBUG', 'SWR_SKIP', { key_type: keyType });
        return;
    }
    inflightRefreshes.add(cacheKey);
    log(`Starting nutri background refresh for ${cacheKey}...`, 'INFO', 'SWR_REFRESH_START', { key_type: keyType });

    // Fire and forget
    (async () => {
        let freshData = null;
        try {
            // Determine which source to refresh (prioritize USDA if requested)
            if (keyType === 'nutri_name_usda_refresh' && query) {
                 log(`Background Refresh: Attempting USDA directly for "${query}"`, 'INFO', 'SWR_REFRESH_USDA_DIRECT');
                 const { data: usdaRawData } = await fetchUsdaSafe(query, log); // Use safe wrapper
                 if (usdaRawData && !usdaRawData.error) {
                     const normalizedResult = normalizeUsdaResponse(usdaRawData, query, log);
                     if (normalizedResult.complete) {
                         freshData = normalizedResult.data; // Successfully got fresh USDA data
                     } else {
                          log(`Background Refresh: USDA parse failed for "${query}"`, 'WARN', 'SWR_REFRESH_USDA_FAIL');
                     }
                 } else {
                     log(`Background Refresh: USDA fetch failed for "${query}"`, 'WARN', 'SWR_REFRESH_USDA_FAIL', { error: usdaRawData?.error });
                 }
            }

            // If USDA wasn't requested for refresh or failed, try the standard flow
            if (!freshData) {
                 log(`Background Refresh: Attempting standard OFF->USDA flow for ${barcode || query}`, 'INFO', 'SWR_REFRESH_STANDARD');
                 freshData = await _fetchNutritionDataFromApi(barcode, query, log);
            }

            // Cache the result if valid and KV configured
            if (freshData && (freshData.status === 'found' || freshData.status === 'not_found')) {
                 if(isKvConfigured()){
                     await kv.set(cacheKey, { data: freshData, ts: Date.now() }, { px: ttlMs });
                     log(`Nutri background refresh successful for ${cacheKey}`, 'INFO', 'SWR_REFRESH_SUCCESS', { status: freshData.status, source: freshData.source, key_type: keyType });
                 } else {
                      log(`Nutri background refresh fetched data but KV not configured, skipping set for ${cacheKey}`, 'WARN', 'SWR_REFRESH_SKIP_KV');
                 }
            } else {
                 log(`Nutri background refresh failed to fetch valid data for ${cacheKey}`, 'WARN', 'SWR_REFRESH_FAIL', { key_type: keyType });
            }
        } catch (error) {
            log(`Nutri background refresh error for ${cacheKey}: ${error.message}`, 'ERROR', 'SWR_REFRESH_ERROR', { key_type: keyType });
        } finally {
            inflightRefreshes.delete(cacheKey); // Remove from inflight set
        }
    })();
}


/**
 * Cache-wrapped function for fetching nutrition data with SWR.
 */
async function fetchNutritionData(barcode, query, log = console.log) {
    const startTime = Date.now();

    if (!isKvConfigured()) {
        log('CRITICAL: UPSTASH_REDIS vars missing. Bypassing cache.', 'CRITICAL', 'CONFIG_ERROR');
        return await _fetchNutritionDataFromApi(barcode, query, log); // Call updated internal logic
    }

    let cacheKey = '';
    let ttlMs = 0;
    let swrMs = 0;
    let keyType = '';
    const identifier = barcode || query;

    if (!identifier) {
        log('Missing barcode or query for nutrition search.', 'WARN', 'INPUT');
        return { status: 'not_found', error: 'Missing barcode or query parameter', source: 'input_error' };
    }

    // Determine cache key based on identifier type
    if (barcode) {
        const barcodeNorm = normalizeKey(barcode);
        cacheKey = `${CACHE_PREFIX_NUTRI}:barcode:${barcodeNorm}`;
        ttlMs = TTL_NUTRI_BARCODE_MS;
        swrMs = SWR_NUTRI_BARCODE_MS;
        keyType = 'nutri_barcode';
    } else { // Use query
        const queryNorm = normalizeKey(query);
        cacheKey = `${CACHE_PREFIX_NUTRI}:name:${queryNorm}`;
        ttlMs = TTL_NUTRI_NAME_MS;
        swrMs = SWR_NUTRI_NAME_MS;
        keyType = 'nutri_name';
    }

    // 1. Check Cache
    let cachedItem = null;
    try {
        cachedItem = await kv.get(cacheKey);
    } catch (error) {
        log(`Cache GET error for ${cacheKey}: ${error.message}`, 'ERROR', 'CACHE_ERROR', { key_type: keyType });
    }

    // Process cache hit
    if (cachedItem && typeof cachedItem === 'object' && cachedItem.data && cachedItem.ts) {
        const ageMs = Date.now() - cachedItem.ts;
        if (ageMs < swrMs) { // Fresh hit
            const latencyMs = Date.now() - startTime;
            log(`Cache Hit (Fresh) for ${cacheKey}`, 'INFO', 'CACHE_HIT', { key_type: keyType, latency_ms: latencyMs, age_ms: ageMs, source: cachedItem.data.source });
            return cachedItem.data;
        } else if (ageMs < ttlMs) { // Stale hit
            const latencyMs = Date.now() - startTime;
            log(`Cache Hit (Stale) for ${cacheKey}, serving stale & refreshing.`, 'INFO', 'CACHE_HIT_STALE', { key_type: keyType, latency_ms: latencyMs, age_ms: ageMs, source: cachedItem.data.source });
            refreshInBackground(cacheKey, barcode, query, ttlMs, log, keyType); // Trigger background refresh
            return cachedItem.data; // Serve stale data
        }
    }

    // 2. Cache Miss or Expired: Fetch Fresh Data
    log(`Cache Miss or Expired for ${cacheKey}`, 'INFO', 'CACHE_MISS', { key_type: keyType });
    const fetchedData = await _fetchNutritionDataFromApi(barcode, query, log); // Call updated internal logic (OFF -> USDA -> Canonical)
    const fetchLatencyMs = Date.now() - startTime;

    // 3. Cache Result (Cache 'found' and 'not_found' statuses)
    if (fetchedData && (fetchedData.status === 'found' || fetchedData.status === 'not_found')) {
        try {
            await kv.set(cacheKey, { data: fetchedData, ts: Date.now() }, { px: ttlMs });
            log(`Cache SET success for ${cacheKey}`, 'DEBUG', 'CACHE_WRITE', { key_type: keyType, status: fetchedData.status, source: fetchedData.source, ttl_ms: ttlMs });
        } catch (error) {
            log(`Cache SET error for ${cacheKey}: ${error.message}`, 'ERROR', 'CACHE_ERROR', { key_type: keyType });
        }
    } else {
        log(`Invalid data received from _fetchNutritionDataFromApi, not caching for ${cacheKey}`, 'ERROR', 'FETCH_INVALID', { fetchedData });
    }

    // Log completion details
    log(`Fetch completed for ${cacheKey}`, 'INFO', 'FETCH_COMPLETE', {
         key_type: keyType,
         status: fetchedData?.status,
         latency_ms: fetchLatencyMs,
         source_used: fetchedData?.source, // Log final source
         reason_incomplete: fetchedData?.reason_incomplete // Log reason if not found
     });
    // Return fetched data (or a default error structure if fetch completely failed)
    return fetchedData || { status: 'not_found', error: 'Internal fetch error', source: 'internal_error', reason_incomplete: 'internal_error' };
}


// --- Vercel Handler ---
module.exports = async (request, response) => {
    response.setHeader('Access-Control-Allow-Origin', '*');
    response.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    response.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    if (request.method === 'OPTIONS') { return response.status(200).end(); }

    try {
        const { barcode, query } = request.query;
        // Simple console logger for handler context
        const log = (message, level = 'INFO', tag = 'HANDLER') => { console.log(`[${level}] [${tag}] ${message}`); };
        const nutritionData = await fetchNutritionData(barcode, query, log); // Use public cached function

        if (nutritionData.status === 'found') {
             return response.status(200).json(nutritionData);
        } else {
             // Return 404 for not_found, include error message/reason if present
             return response.status(404).json({
                  status: 'not_found',
                  message: nutritionData.error || 'Nutrition data not found via OFF, USDA, or Canonical.',
                  reason: nutritionData.reason_incomplete // Pass reason back
              });
        }
    } catch (error) { // Catch unexpected errors in handler
        console.error("Handler error:", error);
        return response.status(500).json({ status: 'error', message: 'Internal server error in nutrition handler.', details: error.message });
    }
};

// Export main function for orchestrator
module.exports.fetchNutritionData = fetchNutritionData;


